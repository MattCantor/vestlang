"use strict";(self.webpackChunk_vestlang_docs=self.webpackChunk_vestlang_docs||[]).push([[934],{5630:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"Types","title":"Types","description":"Helpers","source":"@site/docs/04-Types.md","sourceDirName":".","slug":"/Types","permalink":"/vestlang/Types","draft":false,"unlisted":false,"editUrl":"https://github.com/MattCantor/vestlang/docs/04-Types.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Types","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Evaluation","permalink":"/vestlang/Evaluation"},"next":{"title":"Playground","permalink":"/vestlang/Playground"}}');var o=t(5270),r=t(6336);const i={title:"Types",sidebar_position:4},s=void 0,d={},l=[{value:"Helpers",id:"helpers",level:2},{value:"Enums",id:"enums",level:2},{value:"AST",id:"ast",level:2},{value:"Evaluation",id:"evaluation",level:2}];function c(n){const e={code:"code",h2:"h2",pre:"pre",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h2,{id:"helpers",children:"Helpers"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:'type TwoOrMore<T> = [T, T, ...T[]];\n\ntype SelectorTag = "EARLIER_OF" | "LATER_OF";\n\ninterface Selector<T, K extends SelectorTag = SelectorTag> {\n  type: K;\n  items: TwoOrMore<T>;\n}\n\ninterface EarlierOf<T> extends Selector<T, "EARLIER_OF"> {}\n\ninterface LaterOf<T> extends Selector<T, "LATER_OF"> {}\n\ndeclare const __isoDateBrand: unique symbol;\nexport type OCTDate = string & { [__isoDateBrand]: never };\n'})}),"\n",(0,o.jsx)(e.h2,{id:"enums",children:"Enums"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:'type ConstraintTag = "BEFORE" | "AFTER";\n\ntype VBaseTag = "DATE" | "EVENT";\n\ntype ExprTag = "SINGLETON" | "EARLIER_OF" | "LATER_OF";\n\ntype PeriodTag = "DAYS" | "MONTHS";\n\ntype OffsetTag = "PLUS" | "MINUS";\n\ntype ConditionTag = "ATOM" | "AND" | "OR";\n\ntype AmountTag = "PORTION" | "QUANTITY";\n'})}),"\n",(0,o.jsx)(e.h2,{id:"ast",children:"AST"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:'// "raw" refers to output from the DSL; "canonical" refers to after normalization\ntype Shape = "raw" | "canonical";\n\n/* ------------------------\n * Durations\n * ------------------------ */\n\ninterface Duration {\n  type: "DURATION";\n  value: number;\n  unit: PeriodTag;\n  sign: OffsetTag;\n}\n\ninterface DurationMonth extends Duration {\n  unit: "MONTHS";\n}\n\ninterface DurationDay extends Duration {\n  unit: "DAYS";\n}\n\n/* ------------------------\n * Offsets\n * ------------------------ */\n\ntype Offsets =\n  | readonly []\n  | readonly [DurationMonth | DurationDay]\n  | readonly [DurationMonth, DurationDay];\n\n/* ------------------------\n * Vesting Base\n * ------------------------ */\n\ninterface VestingBase {\n  type: VBaseTag;\n  value: string;\n}\n\ninterface VestingBaseDate extends VestingBase {\n  type: "DATE";\n  value: OCTDate;\n}\n\ninterface VestingBaseEvent extends VestingBase {\n  type: "EVENT";\n  value: string;\n}\n\n/* ------------------------\n * Vesting Node\n * ------------------------ */\n\ninterface VestingNode {\n  type: "SINGLETON";\n  base: VestingBaseDate | VestingBaseEvent;\n  offsets: Offsets;\n  constraints?: Condition;\n}\n\ntype ConstrainedVestingNode = VestingNode & {\n  constraints: Condition;\n};\n\ntype LaterOfVestingNode = LaterOf<VestingNodeExpr>;\n\ntype EarlierOfVestingNode = EarlierOf<VestingNodeExpr>;\n\ntype VestingNodeExpr = VestingNode | LaterOfVestingNode | EarlierOfVestingNode;\n\n/* ------------------------\n * Conditions & Constraints\n * ------------------------ */\n\ninterface BaseCondition {\n  type: ConditionTag;\n}\n\ninterface AtomCondition extends BaseCondition {\n  type: "ATOM";\n  constraint: Constraint;\n}\n\ninterface AndCondition extends BaseCondition {\n  type: "AND";\n  items: TwoOrMore<Condition>;\n}\n\ninterface OrCondition extends BaseCondition {\n  type: "OR";\n  items: TwoOrMore<Condition>;\n}\n\ntype Condition = AtomCondition | AndCondition | OrCondition;\n\ninterface Constraint {\n  type: ConstraintTag;\n  base: VestingNode;\n  strict: boolean;\n}\n\n/* ------------------------\n * Periodicity\n * ------------------------ */\n\ninterface VestingPeriod<S extends Shape = "canonical"> {\n  type: PeriodTag;\n  occurrences: number;\n  length: number;\n  cliff?: S extends "canonical"\n    ? VestingNodeExpr | undefined\n    : Duration | VestingNodeExpr | undefined;\n}\n\ntype RawVestingPeriod = VestingPeriod<"raw">;\n\n/* ------------------------\n * Expressions\n * ------------------------ */\n\ninterface Schedule<S extends Shape = "canonical"> {\n  type: "SINGLETON";\n  vesting_start: S extends "canonical"\n    ? VestingNodeExpr\n    : VestingNodeExpr | null;\n  periodicity: VestingPeriod<S>;\n}\n\ntype RawSchedule = Schedule<"raw">;\n\ntype LaterOfSchedule<S extends Shape = "canonical"> = LaterOf<ScheduleExpr<S>>;\n\ntype EarlierOfSchedule<S extends Shape = "canonical"> = EarlierOf<\n  ScheduleExpr<S>\n>;\n\ntype ScheduleExpr<S extends Shape = "canonical"> =\n  | Schedule<S>\n  | LaterOfSchedule<S>\n  | EarlierOfSchedule<S>;\n\ntype RawScheduleExpr = ScheduleExpr<"raw">;\n\n/* ------------------------\n * Statements\n * ------------------------ */\n\ntype BaseAmount = {\n  type: AmountTag;\n};\n\ninterface AmountQuantity extends BaseAmount {\n  type: "QUANTITY";\n  value: number;\n}\n\ninterface AmountPortion extends BaseAmount {\n  type: "PORTION";\n  numerator: number;\n  denominator: number;\n}\n\ntype Amount = AmountQuantity | AmountPortion;\n\ninterface Statement<S extends Shape = "canonical"> {\n  amount: Amount;\n  expr: ScheduleExpr<S>;\n}\n\ntype RawStatement = Statement<"raw">;\n\ntype Program<S extends Shape = "canonical"> = Statement<S>[];\n\ntype RawProgram = Program<"raw">;\n'})}),"\n",(0,o.jsx)(e.h2,{id:"evaluation",children:"Evaluation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:'interface EvaluationContext {\n  events: { grantDate: OCTDate } & Record<string, OCTDate | undefined>;\n  grantQuantity: number;\n  asOf: OCTDate;\n  vesting_day_of_month: vesting_day_of_month;\n  allocation_type: allocation_type;\n}\n\ntype EvaluationContextInput = Omit<EvaluationContext, "vesting_day_of_month"> &\n  Partial<Pick<EvaluationContext, "vesting_day_of_month" | "allocation_type">>;\n\ntype SymbolicDate =\n  | { type: "START_PLUS"; unit: PeriodTag; steps: number }\n  | { type: "BEFORE_VESTING_START" }\n  | { type: "MAYBE_BEFORE_CLIFF"; date: OCTDate };\n\n/* ------------------------\n * Blockers\n * ------------------------ */\n\ntype UnresolvedBlocker =\n  | {\n      type: "EVENT_NOT_YET_OCCURRED";\n      event: string;\n    }\n  | {\n      type: "UNRESOLVED_SELECTOR";\n      selector: "EARLIER_OF" | "LATER_OF";\n      blockers: Blocker[];\n    }\n  | {\n      type: "DATE_NOT_YET_OCCURRED";\n      date: OCTDate;\n    }\n  | {\n      type: "UNRESOLVED_CONDITION";\n      condition: Omit<VestingNode, "type">;\n    };\n\ntype ImpossibleBlocker =\n  | {\n      type: "IMPOSSIBLE_SELECTOR";\n      selector: "EARLIER_OF" | "LATER_OF";\n      blockers: ImpossibleBlocker[];\n    }\n  | {\n      type: "IMPOSSIBLE_CONDITION";\n      condition: Omit<VestingNode, "type">;\n    };\n\ntype Blocker = UnresolvedBlocker | ImpossibleBlocker;\n\n/* ------------------------\n * Node Meta\n * ------------------------ */\n\ntype NodeResolutionState = "IMPOSSIBLE" | "UNRESOLVED" | "RESOLVED";\n\ntype ResolvedNode = {\n  type: "RESOLVED";\n  date: OCTDate;\n};\n\ntype UnresolvedNode = {\n  type: "UNRESOLVED";\n  blockers: (UnresolvedBlocker | ImpossibleBlocker)[];\n};\n\ntype ImpossibleNode = {\n  type: "IMPOSSIBLE";\n  blockers: ImpossibleBlocker[];\n};\n\ntype NodeMeta = ResolvedNode | UnresolvedNode | ImpossibleNode;\n\n/* ------------------------\n * Tranche\n * ------------------------ */\n\ninterface TrancheMeta {\n  index?: number;\n  state: NodeResolutionState;\n  date?: SymbolicDate;\n  // blockers?: Blocker[];\n  blockers?: string;\n}\n\ninterface BaseTranche {\n  amount: number;\n  date?: OCTDate;\n  meta: TrancheMeta;\n}\n\ninterface ImpossibleTranche extends BaseTranche {\n  amount: number;\n  date?: never;\n  meta: {\n    state: "IMPOSSIBLE";\n    date?: never;\n    blockers: string;\n  };\n}\n\ninterface UnresolvedTranche extends BaseTranche {\n  date?: never;\n  meta: {\n    state: "UNRESOLVED";\n    date: SymbolicDate;\n    blockers: string;\n  };\n}\n\ninterface ResolvedTranche extends BaseTranche {\n  date: OCTDate;\n  meta: {\n    state: "RESOLVED";\n    date?: never;\n    blockers?: never;\n  };\n}\n\ntype Tranche = ImpossibleTranche | UnresolvedTranche | ResolvedTranche;\n'})})]})}function p(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(c,{...n})}):c(n)}},6336:(n,e,t)=>{t.d(e,{R:()=>i,x:()=>s});var a=t(9430);const o={},r=a.createContext(o);function i(n){const e=a.useContext(r);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:i(n.components),a.createElement(r.Provider,{value:e},n.children)}}}]);